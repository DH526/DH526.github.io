<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机网络-域名系统DNS</title>
    <url>/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/</url>
    <content><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>把互连网上的主机名转换为IP地址</p>
<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><p>当某一个应用进程需要把主机名解析为IP地址时，该应用进程就调用<strong>解析程序</strong>，并成为DNS的一个<strong>客户</strong>。</p>
<p>把待解析的域名放在<strong>DNS请求报文</strong>中，以<strong>UDP用户数据报</strong>方式发给<strong>本地域名服务器</strong>。</p>
<p>本地域名服务器在查找域名后，把对应的IP地址放在<strong>回答报文</strong>中返回，应用进程获得目的主机的IP地址。</p>
<p>若本地域名服务器不能回答该请求，则此域名服务器暂时成为DNS的另一个<strong>客户</strong>（递归查询），并向其他域名服务器发出查询请求（一般迭代查询），直至找到能够回答该请求的域名服务器。</p>
<h1 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h1><p>采用<strong>层次树状结构</strong>的命名方法。</p>
<p><strong>域</strong>：名字空间中一个可被管理的划分，域还可以划分为子域，子域还可以划分为子域，形成顶级域、二级域、三级域等等。</p>
<p>DNS不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。</p>
<p>域名是从右往左看的，越往右等级越高。</p>
<h1 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h1><p>DNS服务器的管辖范围是<strong>以区为单位</strong>，区可能等于或小于域，但一定不能大于域，即区是域的子集。</p>
<p>一个服务器所负责管辖（或有权限的）的范围叫做<strong>区</strong>。</p>
<p>一个区中的所有节点必须是能够连通的。</p>
<p><strong>每个区</strong>设置响应的<strong>权限域名服务器</strong>，用来保存该区中的所有主机的域名到IP地址的映射。</p>
<h2 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h2><p>根域名服务器是最高层次的域名服务器。</p>
<p>所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。</p>
<h2 id="顶级域名服务器"><a href="#顶级域名服务器" class="headerlink" title="顶级域名服务器"></a>顶级域名服务器</h2><p>负责管理在该顶级域名下注册的所有二级域名。</p>
<h2 id="权限域名服务器"><a href="#权限域名服务器" class="headerlink" title="权限域名服务器"></a>权限域名服务器</h2><p>负责一个区的域名服务器。</p>
<h2 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h2><p><strong>当一台主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。</strong></p>
<p>不管哪一个<strong>本地域名服务器</strong>，若要对一个域名进行解析，<strong>只要自己无法解析，就首先要求助于根域名服务器</strong>。</p>
<h1 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h1><h2 id="主机向本地域名服务器查询"><a href="#主机向本地域名服务器查询" class="headerlink" title="主机向本地域名服务器查询"></a>主机向本地域名服务器查询</h2><p>一般采用<strong>递归查询</strong>。</p>
<p>如果本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器会以DNS客户的身份，向其他根域名服务器继续发出查询请求报文（即<strong>替主机继续查询</strong>）。</p>
<p>递归查询的结果：</p>
<ul>
<li>查到的IP地址</li>
<li>报错，表示无法查询到所需的IP地址</li>
</ul>
<h2 id="本地域名服务器向根域名服务器查询"><a href="#本地域名服务器向根域名服务器查询" class="headerlink" title="本地域名服务器向根域名服务器查询"></a>本地域名服务器向根域名服务器查询</h2><p>一般采用<strong>迭代查询</strong>。</p>
<p>根域名服务器收到本地域名服务器发出的迭代查询请求报文时，本地域名服务器收到的查询结果有两种：</p>
<ul>
<li>查到的IP地址</li>
<li>下一步向哪个域名服务器查询</li>
</ul>
<p>顶级域名服务器在收到本机域名服务器的查询请求后，收到的结果有两种：</p>
<ul>
<li>查到的IP地址</li>
<li>下一步向哪个权限域名服务器查询</li>
</ul>
<p>就这样，本地域名服务器就这样进行迭代查询，最终把得到的结果返回给发起查询的主机。</p>
<h1 id="高速缓存域名服务器"><a href="#高速缓存域名服务器" class="headerlink" title="高速缓存域名服务器"></a>高速缓存域名服务器</h1><p>功能：用来存放<strong>最近查询过的域名</strong>以及<strong>从何处获得域名映射信息</strong>的记录。</p>
<p>好处：<strong>提高DNS查询效率</strong>，<strong>减轻根域名服务器的负荷</strong>和<strong>减少互联网上的DNS查询报文数量</strong>。</p>
<hr>
<p>作者：<a href="https://github.com/chouxianyu">@臭咸鱼</a></p>
<p>转载请注明出处：<a href="https://chouxianyu.github.io/">https://chouxianyu.github.io</a></p>
<p>欢迎讨论和交流!</p>
<hr>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-实验（二）常用网络指令</title>
    <url>/2019/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol>
<li>学会并掌握常用网络命令。</li>
<li>学会分析在不同参数下显示的数据。</li>
</ol>
<h1 id="实验仪器"><a href="#实验仪器" class="headerlink" title="实验仪器"></a>实验仪器</h1><p>PC机、局域网</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="arp"><a href="#arp" class="headerlink" title="arp"></a>arp</h2><p><strong>知识点扫盲</strong>：地址解析协议，即<em>ARP</em>（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。</p>
<p><strong>功能</strong>：显示和修改IP地址与物理地址之间的转换表</p>
<h3 id="a"><a href="#a" class="headerlink" title="-a"></a>-a</h3><p><strong>功能</strong>：（Windows下）显示当前的ARP信息，可以指定网络地址。</p>
<p>Linux系统中，使用<code>-g</code>。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp -a	<span class="comment"># 显示当前所有的ARP信息</span></span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th align="center">Internet Address</th>
<th align="center">Physical Address</th>
<th align="center">Type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">192.168.1.178</td>
<td align="center">00-16-ec-a0-42-fa</td>
<td align="center">dynamic</td>
</tr>
<tr>
<td align="center">..…</td>
<td align="center">..…</td>
<td align="center">..…</td>
</tr>
</tbody></table>
<p><strong>代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arp -a 192.168.1.178	# 显示指定IP(即192.168.1.178)的ARP信息</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th align="center">Internet Address</th>
<th align="center">Physical Address</th>
<th align="center">Type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">192.168.1.178</td>
<td align="center">00-16-ec-a0-42-fa</td>
<td align="center">dynamic</td>
</tr>
</tbody></table>
<h3 id="s"><a href="#s" class="headerlink" title="-s"></a>-s</h3><p><strong>功能</strong>：添加主机，并将网络地址跟物理地址相对应，这一项是永久生效的。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arp -s 157.55.85.212 00-aa-00-62-c6-09 # 在IP和物理地址转换表中添加一项</span><br><span class="line">arp -a 157.55.85.212	# 显示指定IP(即157.55.85.212)的ARP信息</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th align="center">Internet Address</th>
<th align="center">Physical Address</th>
<th align="center">Type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">157.55.85.212</td>
<td align="center">00-aa-00-62-c6-09</td>
<td align="center"><strong>static</strong></td>
</tr>
</tbody></table>
<p><strong>注意</strong>：这里添加的一个<code>Type</code>为<code>static</code>的。</p>
<h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><p><strong>功能</strong>：删除指定的主机，可以使用* 来删除所有主机。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arp -d 157.55.85.212	# 删除指定IP(即157.55.85.212)</span><br><span class="line">arp -a 157.55.85.212	# 显示指定IP(即157.55.85.212)的ARP信息</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NO ARP Entries Found</span><br></pre></td></tr></table></figure>



<h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h2><p><strong>知识点扫盲</strong>：文件传输协议，即FTP(File Transfer Protocol)。是用于在网络上进行文件传输的一套标准协议，使用客户&#x2F;服务器模式。它属于网络传输协议。</p>
<p>ftp也是一种服务。一旦启动，将创建在其中可以使用ftp命令的子环境，通过键入 <code>quit</code>子命令可以从子环境返回到Windows命令提示符。当 ftp 子环境运行时，它由ftp命令提示符代表。</p>
<p>下边的指令除了ftp是在Windows命令提示符，其他都是在ftp的子环境里。</p>
<p><strong>功能</strong>：控制文件的双向传输（老师说的..…）。</p>
<h3 id="ftp-1"><a href="#ftp-1" class="headerlink" title="ftp"></a>ftp</h3><p><strong>功能</strong>：启动ftp服务。</p>
<p>在命令提示符下，直接输入<code>ftp</code>即可。</p>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p><strong>代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">open 192.168.1.171	# 连接指定的ftp服务器（这里是老师的电脑）</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to 192.168.1.171.</span><br><span class="line">220-Microsoft FTP Service</span><br><span class="line">220 张芳之家</span><br><span class="line">User (192.168.1.171:(none)): zf</span><br><span class="line">331 Password required for zf.</span><br><span class="line">Password:</span><br><span class="line">230-欢迎进入“张芳之家”</span><br><span class="line">230 User zf logged in.</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：上边的第6行需要输入<strong>密码</strong>。我们输的时候，屏幕上并不会显示出来。</p>
<h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><p><strong>功能</strong>：查看本目录下的内容，目录可以理解成文件夹的意思。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dir	# 查看当前目录内容</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">200 PORT command successful.	# 请求成功</span><br><span class="line">150 Opening ASCII mode data connection for /bin/ls.	# ASCII传输方式连接/bin/ls</span><br><span class="line">04-26-13	08:22AM		&lt;DIR&gt;	654	# 有个文件夹，名字是654</span><br><span class="line">226 Transfer complete.</span><br><span class="line">ftp: 收到 44 字节，用时 0.00 Seconds 44000.00Kbyte/sec.</span><br></pre></td></tr></table></figure>

<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p><strong>功能</strong>：更换<strong>远程</strong>目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 654	# 进入文件夹654</span><br><span class="line">dir		# 查看当前目录内容</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">200 PORT command successful.	# 请求成功</span><br><span class="line">150 Opening ASCII mode data connection for /bin/ls.	# ASCII传输方式连接/bin/ls</span><br><span class="line">04-26-13	08:22AM		70	qqq.txt	# 有个文件，名字是qqq.txt</span><br><span class="line">226 Transfer complete.</span><br><span class="line">ftp: 收到 48 字节，用时 0.00 Seconds 44000.00Kbyte/sec.</span><br></pre></td></tr></table></figure>

<h3 id="lcd"><a href="#lcd" class="headerlink" title="lcd"></a>lcd</h3><p><strong>功能</strong>：更换<strong>本地</strong>目录，若无参数，将显示当前目录。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lcd e:\</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Local directory now E:\.</span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p><strong>功能</strong>：将远程文件复制到本地计算机。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get qqq.txt</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">200 PORT command successful.	# 请求成功</span><br><span class="line">150 Opening ASCII mode data connection for qqq.txt(70 bytes)	# ASCII传输方式连接/bin/ls</span><br><span class="line">226 Transfer complete.</span><br><span class="line">ftp: 收到 70 字节，用时 0.00 Seconds 70000.00Kbyte/sec.</span><br></pre></td></tr></table></figure>

<h3 id="quit"><a href="#quit" class="headerlink" title="quit"></a>quit</h3><p><strong>功能</strong>：退出ftp服务。ftp子环境下输入<code>quit</code>即可。</p>
<p><strong>结果</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">221 再见！欢迎下次“张芳之家”</span><br></pre></td></tr></table></figure>

<h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><p><strong>功能</strong>：显示当前的TCP&#x2F;IP配置的设置值。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Windows IP Configuration</span><br><span class="line"></span><br><span class="line">Ethernet adapter 本地连接:</span><br><span class="line">        Connection-specific DNS Suffix  . :</span><br><span class="line">        IP Address. . . . . . . . . . . . : 192.168.1.95	# IP地址</span><br><span class="line">        Subnet Mask . . . . . . . . . . . : 255.255.255.0	# 子网掩码</span><br><span class="line">        Default Gateway . . . . . . . . . : 192.168.1.3		# 缺省网关</span><br></pre></td></tr></table></figure>

<h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p><strong>知识点扫盲</strong>：Telnet协议是TCP&#x2F;IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。</p>
<p><strong>功能</strong>：远程连接另一台计算机</p>
<h3 id="telnet-1"><a href="#telnet-1" class="headerlink" title="telnet"></a>telnet</h3><p><strong>功能</strong>：启动telnet。</p>
<p>在命令提示符下，直接输入<code>telnet</code>即可。</p>
<h3 id="open-1"><a href="#open-1" class="headerlink" title="open"></a>open</h3><p><strong>功能</strong>：连接指定计算机。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">open 192.168.1.94	# 连接我同桌..</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">正在连接到192.168.1.94... </span><br><span class="line">您将要发送密码信息到 Internet 区域中的远程计算机。这可能不安全。是否还要发送(y/n</span><br><span class="line">): n</span><br><span class="line">login:ligong</span><br><span class="line">password:</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：第四行和第五行输入账号和密码，密码并不会显示出来。</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p><strong>功能</strong>：复制文件到自己电脑上</p>
<p><strong>代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">copy qqq.txt c:\	# 复制其e盘qqq.txt到其c盘，前提是此时已在E盘，使用cd e:\实现</span><br></pre></td></tr></table></figure>

<h3 id="quit-1"><a href="#quit-1" class="headerlink" title="quit"></a>quit</h3><p>退出，直接输入<code>quit</code>即可。</p>
<h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><p><strong>知识点扫盲</strong>：它包含了管理网络环境、服务、用户、登陆等Windows 98&#x2F;NT&#x2F;2000 中大部分重要的管理功能。</p>
<h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><p><strong>功能</strong>：将消息发送到网络上的其他用户、计算机或消息名。必须运行信使服务以接收邮件。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net send * 123	# 给所有人发123</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">消息已经送到域 2HJF</span><br></pre></td></tr></table></figure>

<p><strong>代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net send s14 hello	# 给s14机器发hello</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">消息已经送到 S14</span><br></pre></td></tr></table></figure>



<p>作者：<a href="https://github.com/chouxianyu">@臭咸鱼</a></p>
<p>转载请注明出处：<a href="https://chouxianyu.github.io/">https://chouxianyu.github.io</a></p>
<p>欢迎讨论和交流!</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-实验（三）ARP欺骗</title>
    <url>/2019/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%89%EF%BC%89ARP%E6%AC%BA%E9%AA%97/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol>
<li>掌握常见ARP欺骗类型和手段</li>
<li>掌握ARP协议工作原理和格式</li>
<li>掌握防范ARP地址欺骗的方法和措施</li>
<li>掌握Sniffer Pro软件的使用</li>
</ol>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><ul>
<li><p>硬件</p>
<p>  交换机1 台、路由器1台、计算机数台</p>
</li>
<li><p>软件</p>
<p>  <code>Sinffer pro</code></p>
</li>
</ul>
<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>ARP(Address Resolve Protocol)</code>，地址解析协议。</p>
<p><strong>用途</strong>：用于寻找和IP 地址相对应的MAC地址。</p>
<p><strong>ARP消息类型</strong>：</p>
<ul>
<li><p>ARP request</p>
<p>  即ARP请求分组，用于请求某IP主机的硬件地址。</p>
<p>  <strong>广播</strong>。</p>
</li>
<li><p>ARP response</p>
<p>  即ARP响应分组，用于指出某IP主机的硬件地址。</p>
<p>  单播。</p>
</li>
</ul>
<h3 id="ARP报文中各字段的意义"><a href="#ARP报文中各字段的意义" class="headerlink" title="ARP报文中各字段的意义"></a>ARP报文中各字段的意义</h3><ul>
<li><p>硬件类型</p>
<p>  以太网接口类型为1。</p>
</li>
<li><p>协议类型</p>
<p>  IP协议类型为080016。</p>
</li>
<li><p>操作</p>
<p>  ARP请求分组为1，ARP响应分组为2。</p>
</li>
<li><p>硬件地址长度</p>
<p>  MAC地址长度为6BH。</p>
</li>
<li><p>协议地址长度</p>
<p>  IP地址长度为4BH。</p>
</li>
<li><p><strong>源MAC地址</strong></p>
<p>  发送方的MAC地址。</p>
</li>
<li><p><strong>源IP地址</strong></p>
<p>  发送方的IP地址。</p>
</li>
<li><p><strong>目的MAC 地址</strong></p>
<p>  ARP 请求分组中该字段没有意义；ARP 响应分组中为接收方的MAC地址。</p>
</li>
<li><p><strong>目的IP 地址</strong></p>
<p>  ARP 请求分组中为请求解析的IP 地址；ARP 响应分组中为接收方的IP地址。</p>
</li>
</ul>
<h2 id="ARP欺骗原理"><a href="#ARP欺骗原理" class="headerlink" title="ARP欺骗原理"></a>ARP欺骗原理</h2><p><strong>ARP请求分组</strong>以<strong>广播</strong>形式发送，网络上的主机可以自主发送ARP应答消息；</p>
<p>当其他主机收到<strong>ARP响应分组</strong>时，不会检测该报文的真实性，直接将其记录在本地的MAC地址转换表。</p>
<p>就可以发送伪ARP响应分组，从而篡改本地的MAC地址表。</p>
<p>举例：</p>
<p>攻击者<strong>甲</strong>通过冒充某IP主机<strong>丙</strong>，给出错误的物理地址，并向另一主机<strong>乙</strong>单播一个ARP响应分组，这样<strong>乙</strong>接收到这个错误的IP与物理地址的映射，更新了ARP缓存表。</p>
<p>之后，主机<strong>乙</strong>使用ARP缓存表中该项时，则会出现错误。</p>
<h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><h2 id="设置账户"><a href="#设置账户" class="headerlink" title="设置账户"></a>设置账户</h2><p>控制面板——用户账户——设置用户名为<code>ligong</code>，并设置密码。</p>
<h2 id="设置FTP站点"><a href="#设置FTP站点" class="headerlink" title="设置FTP站点"></a>设置FTP站点</h2><p>控制面板——Internet信息服务——FTP站点——硬件——安全账户——浏览——高级——选中<code>ligong</code>——允许匿名——应用、确定。</p>
<h2 id="禁止网络保护"><a href="#禁止网络保护" class="headerlink" title="禁止网络保护"></a>禁止网络保护</h2><p>右击屏幕右下角盾牌，取消<code>Enable Auto Protection</code>。</p>
<h2 id="所用主机说明"><a href="#所用主机说明" class="headerlink" title="所用主机说明"></a>所用主机说明</h2><p>我们需要三台主机，分别为甲、乙、丙。</p>
<p><strong>甲</strong>为监听并攻击者，<strong>乙</strong>为<code>Ping</code>命令&#x2F;<code>FTP</code>命令操作者，<strong>丙</strong>为IP地址提供者。</p>
<p><strong>甲</strong>实现ARP欺骗后，<strong>乙</strong>无法<code>Ping</code>或无法通过<code>FTP</code>连接<strong>丙</strong>。</p>
<h2 id="进行ARP欺骗"><a href="#进行ARP欺骗" class="headerlink" title="进行ARP欺骗"></a>进行ARP欺骗</h2><p>在<strong>甲</strong>主机上进行操作。</p>
<ol>
<li><p>打开<code>Sniffer Pro</code>，选中本机的网卡，并选中<code>Log Off</code>，点击确定。</p>
</li>
<li><p>点击菜单栏中<code>File</code>中的<code>Log On</code>，登录网卡。</p>
</li>
<li><p>打开菜单栏中<code>display</code>中的<code>Define Filter</code>；</p>
<p> 选中<code>Address</code>选项卡，将<code>Station1</code>和<code>Station2</code>设置为<code>Any</code>（这样将监听网络上的所有消息，个人觉得可以只监听乙和丙）；</p>
<p> 选中<code>Advanced</code>选项卡，选中<code>ARP</code>、<code>IP</code>、<code>IP ARP</code>、<code>TCP</code>、<code>UDP</code>和<code>FTP</code>。</p>
</li>
<li><p>打开菜单栏中<code>Capture</code>中的<code>Start</code>，开始监听。</p>
</li>
<li><p>点击左侧<code>Connection</code>，点击下侧的<code>Objects</code>选项。</p>
</li>
<li><p>在右侧找到<strong>乙</strong>对<strong>丙</strong>的<code>ARP</code>信息包，双击，再选择<code>Decode</code>选项，可以看到<code>ARP</code>分组的结构，我们对<strong>丙</strong>的MAC地址进行修改（右击——<code>Edit</code>）。</p>
</li>
<li><p>打开菜单栏中<code>Tools</code>中的<code>Trace Route</code>，实现ARP欺骗。</p>
</li>
</ol>
<h2 id="结果检验"><a href="#结果检验" class="headerlink" title="结果检验"></a>结果检验</h2><p><strong>甲</strong>实现ARP欺骗后，<strong>乙</strong><code>Ping</code>或通过<code>ftp</code>连接<strong>丙</strong>则会失败。</p>
<p>因为<strong>甲</strong>通过广播发出了错误的<strong>丙</strong>的物理地址，而<strong>乙</strong>接收到了这个错误的信息，在连接<strong>丙</strong>时则会使用这个错误的物理地址，造成无法连接。</p>
<h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><p>ARP是建立在网络中各个主机互相信任的基础上的。</p>
<p>ARP欺骗可以导致计算机通信失败，更严重的是可以导致通信重定向，攻击者可以窃取被攻击者通信的数据，存在极大的安全隐患。</p>
<hr>
<p>作者：<a href="https://github.com/chouxianyu">@臭咸鱼</a></p>
<p>转载请注明出处：<a href="https://chouxianyu.github.io/">https://chouxianyu.github.io</a></p>
<p>欢迎讨论和交流!</p>
<hr>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-实验（四）TCP抓包分析</title>
    <url>/2019/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%9E%E9%AA%8C%EF%BC%88%E5%9B%9B%EF%BC%89TCP%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><ul>
<li>学会安装使用自由软件SNORT</li>
<li>截获以太网数据包，并描述以太网数据包的各层的帧结构。</li>
<li>截获ARP，TCP协议数据包并进行分析</li>
</ul>
<h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><p>实验需要两个主机A(192.168.1.104)和B(192.168.1.105)，A访问B，B进行TCP和ARP抓包，本实验报告为抓包主机B视角。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>主机B需要进行环境配置：设置账户密码、打开FTP站点</p>
<h3 id="设置账户密码"><a href="#设置账户密码" class="headerlink" title="设置账户密码"></a>设置账户密码</h3><p>控制面板——用户账户——设置密码</p>
<h3 id="打开FTP站点"><a href="#打开FTP站点" class="headerlink" title="打开FTP站点"></a>打开FTP站点</h3><p>控制面板——管理工具——Internet信息服务——FTP站点——属性——用户名——浏览——查找账户——选择<code>ligong</code>——应用——确认</p>
<h2 id="A访问B"><a href="#A访问B" class="headerlink" title="A访问B"></a>A访问B</h2><ul>
<li><code>ftp</code></li>
<li><code>open 192.168.1.105</code></li>
<li>输入用户名(<code>ligong</code>)和密码(<code>123</code>，也就是刚才设置的密码)</li>
<li>一些操作，如<code>dir</code></li>
<li><code>quit</code>，退出，断开连接</li>
</ul>
<h2 id="B进行抓包"><a href="#B进行抓包" class="headerlink" title="B进行抓包"></a>B进行抓包</h2><p>使用<code>Snort</code>软件进行抓包，进入<code>D:/snort/bin</code>目录。</p>
<p>输入<code>snort -dev -l /snort/log</code>，开始抓包，按下<code>Ctrl+C</code>停止抓包。</p>
<p>如果主机B抓到了A发出的FTP请求，在<code>D:/snort/log</code>目录下可以找到文件夹<code>192.168.104</code>，在其中可以看到名如<code>TCP_1980-21.ids</code>的文件，21为端口号。</p>
<h1 id="数据包分析"><a href="#数据包分析" class="headerlink" title="数据包分析"></a>数据包分析</h1><p>ARP抓包失败，原因未知，其他同学似乎也未抓到，抓到的都是3号机器广播的ARP包。下边进队TCP数据包进行分析。</p>
<h2 id="TCP数据包分析"><a href="#TCP数据包分析" class="headerlink" title="TCP数据包分析"></a>TCP数据包分析</h2><ul>
<li><p>TCP是面向连接的协议，所以TCP运输连接的建立和释放时每一次通信中必不可少的过程。</p>
</li>
<li><p>运输连接分为三个阶段：<strong>连接建立</strong>、<strong>数据传送</strong>、<strong>连接释放</strong>。</p>
<p>  每一次握手大概包括以下内容：</p>
<p>  第一行数据包括了时间戳、源物理地址、目的物理地址、类型、长度；</p>
<p>  第二行数据包括了源IP、目的IP、TCP、TTL、TOS、ID、IP长度、Dgm长度；</p>
<p>  第三行数据包括SYN位、ACK位、序号、确认号、窗口大小、TCP长度；</p>
<p>  第四行信息包括TCP选项等。</p>
</li>
</ul>
<p>以下主要选取TCP数据包中连接建立（三次握手）和连接释放（四次握手）的相关内容进行分析。</p>
<h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>/<span class="number">01</span><span class="number">-01</span>:<span class="number">40</span>:<span class="number">15.948470</span> <span class="number">0</span>:<span class="number">16</span>:EC:D2:<span class="number">50</span>:<span class="number">7</span>D -&gt; <span class="number">0</span>:<span class="number">19</span>:<span class="number">21</span>:<span class="number">57</span>:<span class="number">7</span>:<span class="number">85</span> type:<span class="number">0x800</span> len:<span class="number">0x3E</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.104</span>:<span class="number">1980</span> -&gt; <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>:<span class="number">21</span> TCP TTL:<span class="number">128</span> TOS:<span class="number">0x0</span> ID:<span class="number">11743</span> IpLen:<span class="number">20</span> DgmLen:<span class="number">48</span> DF</span><br><span class="line">******S* Seq: <span class="number">0x75C7623D</span>  Ack: <span class="number">0x0</span>  Win: <span class="number">0xFFFF</span>  TcpLen: <span class="number">28</span></span><br><span class="line"><span class="function">TCP <span class="title">Options</span> <span class="params">(<span class="number">4</span>)</span> </span>=&gt; MSS: <span class="number">1460</span> NOP NOP SackOK </span><br><span class="line"></span><br><span class="line">=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br></pre></td></tr></table></figure>

<p>上边为连接建立的<strong>第一次握手</strong>，可以看到数据包从主机A（104）发往主机B（105）的21号端口；</p>
<p>SYN位设置为1；</p>
<p>序号为<code>0x75C7623D</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>/<span class="number">01</span><span class="number">-01</span>:<span class="number">40</span>:<span class="number">15.948524</span> <span class="number">0</span>:<span class="number">19</span>:<span class="number">21</span>:<span class="number">57</span>:<span class="number">7</span>:<span class="number">85</span> -&gt; <span class="number">0</span>:<span class="number">16</span>:EC:D2:<span class="number">50</span>:<span class="number">7</span>D type:<span class="number">0x800</span> len:<span class="number">0x3E</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>:<span class="number">21</span> -&gt; <span class="number">192.168</span><span class="number">.1</span><span class="number">.104</span>:<span class="number">1980</span> TCP TTL:<span class="number">128</span> TOS:<span class="number">0x0</span> ID:<span class="number">11647</span> IpLen:<span class="number">20</span> DgmLen:<span class="number">48</span> DF</span><br><span class="line">***A**S* Seq: <span class="number">0xF085016</span>  Ack: <span class="number">0x75C7623E</span>  Win: <span class="number">0xFFFF</span>  TcpLen: <span class="number">28</span></span><br><span class="line"><span class="function">TCP <span class="title">Options</span> <span class="params">(<span class="number">4</span>)</span> </span>=&gt; MSS: <span class="number">1460</span> NOP NOP SackOK </span><br><span class="line"></span><br><span class="line">=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br></pre></td></tr></table></figure>

<p>上边为连接建立的<strong>第二次握手</strong>，可以看到数据包从105发往104，</p>
<p>SYN位设置为1；</p>
<p>ACK位设为1；</p>
<p>序号为<code>0xF085016</code>；</p>
<p>确认号为<code>0x75C7623E</code>，即<strong>确认号为上一次握手序号+1的值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>/<span class="number">01</span><span class="number">-01</span>:<span class="number">40</span>:<span class="number">15.948661</span> <span class="number">0</span>:<span class="number">16</span>:EC:D2:<span class="number">50</span>:<span class="number">7</span>D -&gt; <span class="number">0</span>:<span class="number">19</span>:<span class="number">21</span>:<span class="number">57</span>:<span class="number">7</span>:<span class="number">85</span> type:<span class="number">0x800</span> len:<span class="number">0x3C</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.104</span>:<span class="number">1980</span> -&gt; <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>:<span class="number">21</span> TCP TTL:<span class="number">128</span> TOS:<span class="number">0x0</span> ID:<span class="number">11744</span> IpLen:<span class="number">20</span> DgmLen:<span class="number">40</span> DF</span><br><span class="line">***A**** Seq: <span class="number">0x75C7623E</span>  Ack: <span class="number">0xF085017</span>  Win: <span class="number">0xFFFF</span>  TcpLen: <span class="number">20</span></span><br><span class="line"></span><br><span class="line">=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br></pre></td></tr></table></figure>

<p>上边为连接建立的<strong>第三次握手</strong>，可以看到数据包从104发往105，</p>
<p>ACK位设为1；</p>
<p>序号为<code>0x75C7623E</code>，即<strong>序号为上一次握手的确认号</strong>，本质是A上一次向B发出的请求的序号+1；</p>
<p>确认号为<code>0xF085017</code>，即<strong>确认号为上一次握手序号+1的值</strong>。</p>
<h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p><img src="https://i.loli.net/2019/06/06/5cf7f404924bd20321.png" alt="TCP数据包.png"></p>
<h3 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放"></a>连接释放</h3><p><strong>注意</strong>：这里是<strong>服务器主动释放连接</strong>，与教材上写的客户机主动释放情况不同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>/<span class="number">01</span><span class="number">-01</span>:<span class="number">40</span>:<span class="number">25.769622</span> <span class="number">0</span>:<span class="number">19</span>:<span class="number">21</span>:<span class="number">57</span>:<span class="number">7</span>:<span class="number">85</span> -&gt; <span class="number">0</span>:<span class="number">16</span>:EC:D2:<span class="number">50</span>:<span class="number">7</span>D type:<span class="number">0x800</span> len:<span class="number">0x36</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>:<span class="number">21</span> -&gt; <span class="number">192.168</span><span class="number">.1</span><span class="number">.104</span>:<span class="number">1980</span> TCP TTL:<span class="number">128</span> TOS:<span class="number">0x0</span> ID:<span class="number">11666</span> IpLen:<span class="number">20</span> DgmLen:<span class="number">40</span> DF</span><br><span class="line">***A***F Seq: <span class="number">0xF085092</span>  Ack: <span class="number">0x75C7625B</span>  Win: <span class="number">0xFFE2</span>  TcpLen: <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>上边为连接释放的<strong>第一次握手</strong>，可以看到数据包从105发往104，</p>
<p>ACK位设为1；</p>
<p>FIN位设为1；</p>
<p>序号为<code>0xF085092</code>；</p>
<p>确认号为<code>0x75C7625B</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>/<span class="number">01</span><span class="number">-01</span>:<span class="number">40</span>:<span class="number">25.769759</span> <span class="number">0</span>:<span class="number">16</span>:EC:D2:<span class="number">50</span>:<span class="number">7</span>D -&gt; <span class="number">0</span>:<span class="number">19</span>:<span class="number">21</span>:<span class="number">57</span>:<span class="number">7</span>:<span class="number">85</span> type:<span class="number">0x800</span> len:<span class="number">0x3C</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.104</span>:<span class="number">1980</span> -&gt; <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>:<span class="number">21</span> TCP TTL:<span class="number">128</span> TOS:<span class="number">0x0</span> ID:<span class="number">11763</span> IpLen:<span class="number">20</span> DgmLen:<span class="number">40</span> DF</span><br><span class="line">***A**** Seq: <span class="number">0x75C7625B</span>  Ack: <span class="number">0xF085093</span>  Win: <span class="number">0xFF84</span>  TcpLen: <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>上边为连接释放的<strong>第二次握手</strong>，可以看到数据包从104发往105，</p>
<p>ACK位设为1；</p>
<p>序号为<code>0x75C7625B</code>，即<strong>序号等于上次握手确认号</strong>；</p>
<p>确认号为<code>0xF085093</code>，即<strong>确认号等于上次握手序号+1</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>/<span class="number">01</span><span class="number">-01</span>:<span class="number">40</span>:<span class="number">25.771844</span> <span class="number">0</span>:<span class="number">16</span>:EC:D2:<span class="number">50</span>:<span class="number">7</span>D -&gt; <span class="number">0</span>:<span class="number">19</span>:<span class="number">21</span>:<span class="number">57</span>:<span class="number">7</span>:<span class="number">85</span> type:<span class="number">0x800</span> len:<span class="number">0x3C</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.104</span>:<span class="number">1980</span> -&gt; <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>:<span class="number">21</span> TCP TTL:<span class="number">128</span> TOS:<span class="number">0x0</span> ID:<span class="number">11764</span> IpLen:<span class="number">20</span> DgmLen:<span class="number">40</span> DF</span><br><span class="line">***A***F Seq: <span class="number">0x75C7625B</span>  Ack: <span class="number">0xF085093</span>  Win: <span class="number">0xFF84</span>  TcpLen: <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>上边为连接释放的<strong>第三次握手</strong>，可以看到数据包从104发往105，</p>
<p>ACK位设为1；</p>
<p>FIN位设置为1；</p>
<p>序号为<code>0x75C7625B</code>，即<strong>序号等于上次握手序号</strong>；</p>
<p>确认号为<code>0xF085093</code>，即<strong>确认号等于上次握手确认号</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>/<span class="number">01</span><span class="number">-01</span>:<span class="number">40</span>:<span class="number">25.771894</span> <span class="number">0</span>:<span class="number">19</span>:<span class="number">21</span>:<span class="number">57</span>:<span class="number">7</span>:<span class="number">85</span> -&gt; <span class="number">0</span>:<span class="number">16</span>:EC:D2:<span class="number">50</span>:<span class="number">7</span>D type:<span class="number">0x800</span> len:<span class="number">0x36</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>:<span class="number">21</span> -&gt; <span class="number">192.168</span><span class="number">.1</span><span class="number">.104</span>:<span class="number">1980</span> TCP TTL:<span class="number">128</span> TOS:<span class="number">0x0</span> ID:<span class="number">11667</span> IpLen:<span class="number">20</span> DgmLen:<span class="number">40</span> DF</span><br><span class="line">***A**** Seq: <span class="number">0xF085093</span>  Ack: <span class="number">0x75C7625C</span>  Win: <span class="number">0xFFE2</span>  TcpLen: <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>上边为连接释放的<strong>第四次握手</strong>，可以看到数据包从105发往104，</p>
<p>ACK位设为1；</p>
<p>序号为<code>0xF085093</code>，即<strong>序号等于上次握手确认号</strong>；</p>
<p>确认号为<code>0x75C7625C</code>，即<strong>确认号等于上次握手序号+1</strong>。</p>
<h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><p>本次实验前在计算机网络课堂上还并没有学过TCP的连接过程如何建立与释放，仅仅听说过三次握手和四次握手。</p>
<p>通过这次实验，更加直观、具体地看到了TCP建立和释放连接的过程。在实验之后，又通过学习，对三次握手和四次握手的原理有了进一步的了解。</p>
<p>问：为什么建立连接是三次握手，释放连接是四次握手？</p>
<p>答：</p>
<ul>
<li>建立连接时，服务器收到客户的SYN连接请求报文，可以直接发送SYN+ACK报文，其中ACK报文是用来应答的，SYN报文是用来同步的。</li>
<li>当释放连接时，当服务器收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端：“你发的FIN报文我收到了”。只有等到服务器所有的报文都发送完了，它才能发送FIN报文，因此ACK报文和FIN报文不能一起发送，故需要四步握手。</li>
</ul>
<hr>
<p>作者：<a href="https://github.com/chouxianyu">@臭咸鱼</a></p>
<p>转载请注明出处：<a href="https://chouxianyu.github.io/">https://chouxianyu.github.io</a></p>
<p>欢迎讨论和交流!</p>
<hr>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-数据链路层复习</title>
    <url>/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>网桥在数据链路层进行互连。</p>
<h1 id="数据链路层研究的问题"><a href="#数据链路层研究的问题" class="headerlink" title="数据链路层研究的问题"></a>数据链路层研究的问题</h1><p>在同一个局域网中，<strong>分组</strong>怎么从一台主机传送到另一台主机上（不经过路由器转发）。</p>
<p><strong>分组是网络层的协议数据单元</strong>，数据链路层的协议数据单元是<strong>帧</strong>。</p>
<h1 id="链路和数据链路"><a href="#链路和数据链路" class="headerlink" title="链路和数据链路"></a>链路和数据链路</h1><h2 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h2><p>也叫物理链路。</p>
<p>一个结点到相邻结点的一段<strong>物理线路</strong>，而没有其他的交换结点。</p>
<h2 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h2><p>也叫逻辑链路。</p>
<p><strong>链路</strong>加上实现协议的<strong>硬件</strong>和<strong>软件</strong>形成数据链路。</p>
<p>常用方法：</p>
<p>网络适配器，即网卡，既有软件，又包括硬件，其一般包括物理层和数据链路层两层的功能。</p>
<h2 id="链路和数据链路有什么区别？“电路接通了”和“数据链路接通了”的区别在哪？"><a href="#链路和数据链路有什么区别？“电路接通了”和“数据链路接通了”的区别在哪？" class="headerlink" title="链路和数据链路有什么区别？“电路接通了”和“数据链路接通了”的区别在哪？"></a>链路和数据链路有什么区别？“电路接通了”和“数据链路接通了”的区别在哪？</h2><p>所谓<strong>链路就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点</strong>。在进行数据通信时，两个计算机之间的通信路径往往要经过许多段这样的链路。可见链路只是一条路径的组成部分。</p>
<p>数据链路则是另外一个概念。这是因为<strong>当需要在一条线路上传输数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路</strong>。现在最常用的方法是使用网络适配器（如拨号上网使用拨号适配器，以及通过以太网上网使用局域网适配器）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</p>
<p>也可以把链路分为物理链路和逻辑链路。物理链路就是上面说的链路，而逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。</p>
<p><strong>“电路接通了”表明物理连接已经能够传输比特流了</strong>。</p>
<p><strong>而“数据链路接通了”是指在物理连通的基础上，建立数据链路，实现封装成帧、透明传输、差错检测等功能</strong>。</p>
<h1 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h1><p>数据链路层的<strong>协议数据单元</strong>。</p>
<h1 id="数据链路层三个基本问题"><a href="#数据链路层三个基本问题" class="headerlink" title="数据链路层三个基本问题"></a>数据链路层三个基本问题</h1><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>数据链路层在网络层交下来的IP数据报（即分组）前后分别添加<strong>首部</strong>和<strong>尾部</strong>形成<strong>帧</strong>。（OSI的数据链路层把传输的比特流划分成帧。）</p>
<p><strong>只有数据链路层会添加尾部，除物理层外，即应用层、传输层、网络层、数据链路层都会为上边传下来的数据添加首部</strong>。</p>
<p>首部和尾部包括许多必要的控制信息（如同步信息、地址信息、差错控制等），</p>
<h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>为使接收端能从收到的比特流中准确地找到帧的开始和结束位置。</p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>首部和尾部的一个重要作用就是<strong>帧定界</strong>（即确定帧的界限）：</p>
<p>SOH（Start Of Header），放在帧的最前边，表示帧的开始。</p>
<p>EOT（End Of Transmission），放在帧的最后边，表示帧的结束。</p>
<h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><h3 id="问题来源-1"><a href="#问题来源-1" class="headerlink" title="问题来源"></a>问题来源</h3><p>由于帧开始和结束的标记使用专门指明的控制字符，所传输的数据中不能出现8比特的组合和用作帧定界的控制字符的比特编码一样，否则会出现<strong>帧定界错误</strong>。</p>
<h3 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h3><ul>
<li>解决方法：<strong>字节填充</strong></li>
</ul>
<p>发送端的数据链路层在<strong>数据中控制字符和转义字符</strong>的前边插入一个<strong>转义字符</strong>ESC；</p>
<p>接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符ESC。</p>
<p>简单来说，（要注意：添加和删除ESC是对于<strong>数据中的</strong>ESC、SOH、EOT来说的）</p>
<p><strong>发送端的数据链路层在数据中的ESC、SOH、EOT前添加ESC</strong>，</p>
<p><strong>接收端的数据链路层把数据中ESC、SOH、EOT前的ESC去掉</strong></p>
<h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><h3 id="问题来源-2"><a href="#问题来源-2" class="headerlink" title="问题来源"></a>问题来源</h3><ul>
<li><strong>比特差错</strong></li>
</ul>
<p>现实的通信链路不是理想的，传输过程中可能出现<strong>比特差错</strong>（1变成0，或0变成1）。</p>
<p><strong>比特差错并不是传输差错</strong>。</p>
<p>为保证数据传输的可靠性，必须进行差错检测。</p>
<h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><p>数据链路层广泛使用了<strong>循环冗余校验码CRC</strong>的检错技术。</p>
<p>若数据链路层<strong>仅仅</strong>使用CRC，则只能实现<strong>无差错接受</strong>、<strong>无比特差错</strong>的传输，这并不是<strong>可靠传输</strong>。</p>
<p>&#x3D;&#x3D;CRC可参考计组复习笔记，超链接&#x3D;&#x3D;</p>
<ul>
<li>CRC和FCS不同</li>
</ul>
<p><strong>帧检验序列FCS</strong>，是数据后边的<strong>冗余码</strong>；而CRC是一种检错方法。</p>
<ul>
<li>编码方法</li>
</ul>
<p>数据左移几位（P的位数-1）后模2除以生成多项式P，则得应在数据后添加的余数</p>
<ul>
<li>检错方法</li>
</ul>
<p>拿到的数据加冗余码，模2除生成多项式P，求得余数</p>
<p>若余数为0，则无误，接受；</p>
<p>若不为0，则有误，就<strong>丢弃</strong>。</p>
<h2 id="为什么三个问题必须加以解决"><a href="#为什么三个问题必须加以解决" class="headerlink" title="为什么三个问题必须加以解决"></a>为什么三个问题必须加以解决</h2><p><strong>封装成帧就是在一段数据的前后分别添加首部和尾部</strong>（在首部和尾部里面有许多必要的控制信息），这样就构成了一个帧。接收端在收到物理层上交的比特流，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。<strong>首部和尾部的一个重要作用就是帧定界，如果不进行封装成帧，那么数据链路层在收到一些数据时，就无法知道对方传输的数据中哪些是数据，哪些是控制信息，甚至数据中有没有差错也不知道，也无法知道数据传送结束了没有，因此不知道应该在什么时候把收到的数据给上一层。</strong></p>
<p><strong>上层交下来的数据，不管是什么形式的比特组合，都必须能够正确传送</strong>。由于帧的开始和结束的标记是使用专门指明的控制字符，因此，所传输的数据中的任何比特组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。<strong>数据链路层不应对传送的数据提出限制，即不应当规定某种形式的比特组合不能够传送。如果没有透明传输，就可能会出现帧定界错误</strong>。</p>
<p>如果数据链路层没有<strong>差错检测</strong>，那么当目的主机收到其他主机发送来的数据时，在交给高层后，<strong>如果应用程序要求收到的数据必须正确无误</strong>，那么目的主机的高层软件可以对收到的数据进行差错检测。如果发现数据中有差错，就可以请求源主机<strong>重传</strong>这些数据。这样做就可以达到正确接收数据的目的。但这种工作方式有一个很大的缺点，就是<strong>一些在传输过程中出现了错误的数据（这些已经是没有用处的数据）还会继续在网络中传送，这样就浪费了网络的资源</strong>。</p>
<h1 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h1><p>PPP协议<strong>面向连接</strong>。</p>
<p>PPP控制字符：<code>0x7E</code></p>
<h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><p>简单</p>
<h2 id="字节填充"><a href="#字节填充" class="headerlink" title="字节填充"></a>字节填充</h2><p>PPP使用异步传输时，转义符定义为<code>0x7D</code>，使用字节填充</p>
<table>
<thead>
<tr>
<th align="center">处理情况</th>
<th align="center">填充前</th>
<th align="center">填充后</th>
</tr>
</thead>
<tbody><tr>
<td align="center">控制字符</td>
<td align="center">0x7E</td>
<td align="center">(0x7D,0x5E)</td>
</tr>
<tr>
<td align="center">转义字符</td>
<td align="center">0x7D</td>
<td align="center">(0x7D,0x5D)</td>
</tr>
<tr>
<td align="center">ASCII码控制字符(小于0x20)</td>
<td align="center">0x03</td>
<td align="center">(0x7D,0x23)</td>
</tr>
</tbody></table>
<h2 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h2><p>PPP使用同步传输时</p>
<p>保证<strong>信息字段中</strong>不会出现连续6个1，方法如下</p>
<ul>
<li><p>发送端</p>
<p>  扫描<strong>信息字段</strong>，发现<strong>连续5个1</strong>，在其后边添1个0</p>
</li>
<li><p>接收端</p>
<p>  扫描<strong>信息字段</strong>，发现<strong>连续5个1</strong>，则删除其后边的1个0</p>
</li>
</ul>
<h1 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h1><p><strong>局域网的协议结构一般不包括网络层</strong>。</p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网是典型的局域网，几乎成了局域网的同义词。</p>
<p>为了通信的简便，以太网采取了以下两种措施：</p>
<ul>
<li><strong>无连接、不可靠</strong></li>
<li>以太网发送的数据都使用<strong>曼彻斯特编码</strong></li>
</ul>
<h2 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h2><p>以太网使用截断二进制指数退避算法来确定碰撞后重传的时机。</p>
<p>设碰撞次数为$k$，则$k&#x3D;Min[重传次数，10]$，重传时间为$0$到$2^k-1$个时间片</p>
<h2 id="局域网主要特点"><a href="#局域网主要特点" class="headerlink" title="局域网主要特点"></a>局域网主要特点</h2><ul>
<li>网络为一个单位所拥有</li>
<li>地理范围和站点数目均有限</li>
</ul>
<h2 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h2><h3 id="星形网"><a href="#星形网" class="headerlink" title="星形网"></a>星形网</h3><p>现在主要用这个，</p>
<p><strong>集线器星型拓扑</strong>：</p>
<ul>
<li>易维护，物理上是星形，逻辑上是总线型</li>
<li><strong>集线器工作在物理层</strong></li>
</ul>
<h3 id="环形网"><a href="#环形网" class="headerlink" title="环形网"></a>环形网</h3><p>一个电脑出问题，会影响整个局域网。</p>
<h3 id="总线网"><a href="#总线网" class="headerlink" title="总线网"></a>总线网</h3><p>所有的主机都连在一根总线上。</p>
<ul>
<li><p>广播</p>
<p>  一台计算机发送数据，总线上所有计算机都能检测到这个数据</p>
</li>
<li><p>一对一</p>
<p>  给每个适配器一个独一无二的MAC地址，在发送数据帧时，在帧的首部写明接收站的地址。</p>
<p>  当数据帧中的目的地址与适配器ROM中存放的MAC地址一致时，该适配器才接受这个数据帧，否则丢弃。</p>
</li>
</ul>
<h2 id="CSMA-x2F-CD协议"><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h2><p>载波监听多路访问&#x2F;碰撞检测，协议的实质是载波监听和碰撞检测。</p>
<h1 id="以太网扩展"><a href="#以太网扩展" class="headerlink" title="以太网扩展"></a>以太网扩展</h1><hr>
<p>作者：<a href="https://github.com/chouxianyu">@臭咸鱼</a></p>
<p>转载请注明出处：<a href="https://chouxianyu.github.io/">https://chouxianyu.github.io</a></p>
<p>欢迎讨论和交流!</p>
<hr>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-物理层复习</title>
    <url>/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="物理层主要解决的问题"><a href="#物理层主要解决的问题" class="headerlink" title="物理层主要解决的问题"></a>物理层主要解决的问题</h1><p>进行<strong>信号和比特流的转换</strong>，实现<strong>透明传输比特流</strong>，尽量使数据链路层感觉不到传输媒体之间的差异。</p>
<h1 id="物理层的主要任务"><a href="#物理层的主要任务" class="headerlink" title="物理层的主要任务"></a>物理层的主要任务</h1><h2 id="机械特性"><a href="#机械特性" class="headerlink" title="机械特性"></a>机械特性</h2><p>接插件的形状、尺寸、引脚数目和排列等<strong>规格</strong></p>
<h2 id="电气特性"><a href="#电气特性" class="headerlink" title="电气特性"></a>电气特性</h2><p><strong>电压范围</strong></p>
<h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><p>某电平<strong>电压的意义</strong></p>
<h2 id="过程特性"><a href="#过程特性" class="headerlink" title="过程特性"></a>过程特性</h2><p>不同功能的各种可能<strong>事件的出现顺序</strong>。</p>
<h1 id="协议数据单元"><a href="#协议数据单元" class="headerlink" title="协议数据单元"></a>协议数据单元</h1><p>物理层上所传数据的单位是<strong>比特</strong>。</p>
<h1 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h1><h2 id="源系统"><a href="#源系统" class="headerlink" title="源系统"></a>源系统</h2><h3 id="源点"><a href="#源点" class="headerlink" title="源点"></a>源点</h3><p>又称信源，源站。</p>
<p>产生要传输的数据（比特流）。</p>
<h3 id="发送器"><a href="#发送器" class="headerlink" title="发送器"></a>发送器</h3><p>对源点生成的比特流进行编码，然后在传输系统中进行传输。</p>
<h2 id="传输系统"><a href="#传输系统" class="headerlink" title="传输系统"></a>传输系统</h2><p>可以是简单的传输线，也可以是复杂的网络系统。</p>
<h2 id="目的系统"><a href="#目的系统" class="headerlink" title="目的系统"></a>目的系统</h2><h3 id="接收器"><a href="#接收器" class="headerlink" title="接收器"></a>接收器</h3><p>接收信号，转换为终点可以处理的信息。</p>
<p>比如解调器，把模拟信号还原为比特流。</p>
<h3 id="终点"><a href="#终点" class="headerlink" title="终点"></a>终点</h3><p>又称目的站、信宿。</p>
<p>获取接收器传来的比特流。</p>
<h1 id="通信常用术语"><a href="#通信常用术语" class="headerlink" title="通信常用术语"></a>通信常用术语</h1><p>通信的目的是传送消息。</p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>消息是<strong>本质</strong>。</p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据是运送消息的<strong>实体</strong>。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是数据的<strong>电气或电磁表现</strong>。</p>
<h1 id="信号的分类"><a href="#信号的分类" class="headerlink" title="信号的分类"></a>信号的分类</h1><p>根据信号中代表消息的参数的取值方式分类</p>
<h2 id="模拟信号"><a href="#模拟信号" class="headerlink" title="模拟信号"></a>模拟信号</h2><p>代表消息的参数取值是<strong>连续</strong>的。</p>
<h2 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h2><p>代表消息的参数取值是<strong>离散</strong>的。</p>
<p><strong>码元</strong>：承载信息的基本信号单位。</p>
<p>有两个要素：码元的取值个数$M$（$M$进制码元）和码元携带的信息量（即码元的位数）$n$。</p>
<p>$n\geq log_2^M$</p>
<p><a href="https://zhidao.baidu.com/question/680218902599074452.html">https://zhidao.baidu.com/question/680218902599074452.html</a></p>
<h1 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">基带信号</th>
<th align="center">带通信号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">频率</td>
<td align="center">低，甚至有直流成分</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">传播距离</td>
<td align="center">短</td>
<td align="center">远</td>
</tr>
</tbody></table>
<p>许多信道并不能传输低频分量或直流分量。为解决这个问题，必须对基带信号进行<strong>调制</strong>。</p>
<h2 id="基带调制"><a href="#基带调制" class="headerlink" title="基带调制"></a>基带调制</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>又称<strong>编码</strong>。</p>
<p>仅对基带信号的<strong>波形进行变换</strong>，使其与信道特性相适应。</p>
<p>变换后的信号仍为<strong>基带信号</strong>。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>不归零制</li>
<li>归零制</li>
<li><strong>曼彻斯特编码</strong></li>
<li>差分曼彻斯特编码</li>
</ul>
<h2 id="载波调制"><a href="#载波调制" class="headerlink" title="载波调制"></a>载波调制</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>使用<strong>载波</strong>，把基带信号的<strong>频率范围搬移到较高的频段</strong>，并转换为模拟信号。</p>
<p>经过载波调制后的信号称为<strong>带通信号</strong>，带通指仅在一段频率范围内能够通过信道。</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul>
<li>调幅</li>
<li>调频</li>
<li>调相</li>
</ul>
<h1 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h1><p>信道指向某一个方向传送信息的媒体。</p>
<p>一条通信线路往往包含一条发送信道和一条接收信道。</p>
<h1 id="三种通信基本方式"><a href="#三种通信基本方式" class="headerlink" title="三种通信基本方式"></a>三种通信基本方式</h1><p>从通信的双方信息交换的方式来看</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">单工通信</th>
<th align="center">半双工通信</th>
<th align="center">全双工通信</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通信方向</td>
<td align="center">通信只能有一个方向</td>
<td align="center">双向交替通信</td>
<td align="center">双向同时通信</td>
</tr>
<tr>
<td align="center">信道数</td>
<td align="center">一条</td>
<td align="center">两条</td>
<td align="center">两条</td>
</tr>
</tbody></table>
<h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><p>信号在信道上传输会失真。</p>
<p>从概念上讲，限制码元在信道上的传输速率的因素有两个：</p>
<h2 id="信道能够通过的频率范围"><a href="#信道能够通过的频率范围" class="headerlink" title="信道能够通过的频率范围"></a>信道能够通过的频率范围</h2><p><strong>码间串扰</strong>：接收端收到的信号波形失去了码元之间的清晰界限。</p>
<p><strong>奈氏准则</strong>：指出在假定的理想条件下，为避免码间串扰，码元的传输速率的上限值。</p>
<p><strong>在任何信道中，码元的传输速率是有上限的，超过上限，就会出现严重的码间串扰问题。</strong></p>
<p><strong>波特</strong>：Baud，码元传输速率的单位。1 Baud即每秒传送1个码元。</p>
<h2 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h2><p><strong>信噪比</strong>就是信号平均功率$S$和噪声平均功率$N$之比，常记为$S&#x2F;N$，并用分贝$dB$作为度量单位。<br>$$<br>信噪比(dB)&#x3D;10log_{10}^{S&#x2F;N}(dB)<br>$$<br><strong>香农公式</strong>指出，信道的<strong>极限信息传输速率</strong>$C$是：<br>$$<br>C&#x3D;W\ log_2^{1+S&#x2F;N}(bit&#x2F;s)<br>$$<br>式中，$W$为信道的带宽，单位为$Hz$。</p>
<p>香农公式表明：<strong>信道的带宽或信噪比越大，信道的极限传输速率就越大。</strong></p>
<h2 id="其他因素"><a href="#其他因素" class="headerlink" title="其他因素"></a>其他因素</h2><p>对于频带宽度、信噪比和码元传输速率已确定的信道，我们可以通过<strong>让每一个码元携带更多的信息量</strong>提高信息的传输速率。</p>
<p><strong>码元个数不是越多越好。</strong></p>
<p>如果每个码元携带的信息量$n$越大，即码元取值的数量越多，则在接收端进行调解时<strong>要正确识别每一个码元就越困难</strong>，导致出错率增加。</p>
<h1 id="奈氏准则和香农公式的主要区别"><a href="#奈氏准则和香农公式的主要区别" class="headerlink" title="奈氏准则和香农公式的主要区别"></a>奈氏准则和香农公式的主要区别</h1><ul>
<li><p>奈氏准则指出了，<strong>码元传输速率</strong>是受限的，不能任意提高，否则在接收端就无法正确判定码元是1还是0（因为有码元之间的相互干扰）。</p>
<p>  奈氏准则是在理想条件下推导出的。在实际条件下，最高码元传输速率要比理想条件下得出的数值还要小些。电信工程技术人员的任务就是要在实际条件下，寻找出较好的传输码元波形，将比特转换为较为合适的传输信号。</p>
<p>  需要注意的是，<strong>奈氏准则并没有对信息传输速率给出限制</strong>。<strong>要提高信息传输速率就必须使每一个传输的码元能够代表许多个比特的信息</strong>。这就需要很好的编码技术。</p>
</li>
<li><p>香农公式给出了<strong>信息传输速率</strong>的极限，即对于一定的传输带宽（以赫兹为单位）和一定的信噪比，信息传输速率的上限就确定了。这个极限是不能够突破的。<strong>要想提高信息的传输速率，或者必须设法提高传输线路的带宽，或者必须设法提高所传信号的信噪比，此外没有其他任何办法</strong>。</p>
<p>  香农公式告诉我们，若要得到无限大的信息传输速率，只有两个办法：要么使用无限大的传输带宽，要么使信号的信噪比无限大（即采用没有噪声的传输信道或使用无限大的发送功率）。当然这都是不可能的。</p>
</li>
</ul>
<h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><p>物理层的“连接”不一定是使用导线的“连接”，比如无线连接就不是使用导线的“连接”。</p>
<h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><h2 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h2><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><p><strong>复用</strong>：允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p>
<h2 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h2><p>所有用户在<strong>同一时间</strong>占用<strong>不同的带宽资源</strong>。</p>
<p>用户在分配到一定的频带后，在通信过程中<strong>自始至终都占用</strong>这个频带。</p>
<ul>
<li><strong>波分复用</strong></li>
</ul>
<p>就是光的频分复用。</p>
<h2 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h2><p>又称同步时分复用。考过图2-15。</p>
<p>所用用户在<strong>不同时间</strong>内用<strong>同样的频度带宽</strong>。</p>
<p>由于计算机数据的突发性质，时分复用时一个用户对已经分配到的子信道的利用率一般是不高的。</p>
<ul>
<li><strong>统计时分复用</strong></li>
</ul>
<p>与同步时分复用相比，它按需动态分配时间。</p>
<h2 id="频分复用和时分复用的优缺点"><a href="#频分复用和时分复用的优缺点" class="headerlink" title="频分复用和时分复用的优缺点"></a>频分复用和时分复用的优缺点</h2><ul>
<li><p>优点</p>
<p>  技术比较成熟</p>
</li>
<li><p>缺点</p>
<p>  不够灵活</p>
</li>
</ul>
<h2 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h2><p>又称码分多址。</p>
<p>各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</p>
<p>每个用户<strong>可以</strong>在<strong>同样的时间</strong>使用<strong>同样的频带</strong>进行通信。</p>
<h3 id="码片定义"><a href="#码片定义" class="headerlink" title="码片定义"></a>码片定义</h3><p>每一个比特用m个比特表示，这m个比特称为<strong>码片</strong>。</p>
<p>每个用户发送的是码片（代表1）、码片反码（代表0）或不发送。</p>
<p>接收方用想接收的发送方的码片与收到的信号进行规格化內积。</p>
<p>若规格化內积为1，则发送方发送了码片，即1；若为-1，则发送方发送了码片反码，即0。</p>
<h3 id="码片特点"><a href="#码片特点" class="headerlink" title="码片特点"></a>码片特点</h3><p>內积：同位相乘之和</p>
<p>规格化內积：內积除以位数</p>
<p>正交：內积为0</p>
<ul>
<li>分配给每个用户的码片必须各不相同，并且相互正交。</li>
<li>某用户码片与其他用户码片（或码片的反码）內积为0。</li>
<li>码片与自身规格化內积为1。</li>
<li>码片与自身反码规格化內积为-1。</li>
</ul>
<hr>
<p>作者：<a href="https://github.com/chouxianyu">@臭咸鱼</a></p>
<p>转载请注明出处：<a href="https://chouxianyu.github.io/">https://chouxianyu.github.io</a></p>
<p>欢迎讨论和交流!</p>
<hr>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-第一章复习</title>
    <url>/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Internet如何翻译"><a href="#Internet如何翻译" class="headerlink" title="Internet如何翻译"></a>Internet如何翻译</h1><p>有两种翻译方式：</p>
<h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><p>国家推荐</p>
<h2 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h2><p>现实中大多使用这个词。</p>
<h1 id="互联网的重要特点"><a href="#互联网的重要特点" class="headerlink" title="互联网的重要特点"></a>互联网的重要特点</h1><h2 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h2><p>世界各地的用户都可以交换信息，好像彼此之间直接连通一样。</p>
<h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>即资源共享，如信息、软件、硬件共享等。</p>
<h1 id="两个认识互联网的角度"><a href="#两个认识互联网的角度" class="headerlink" title="两个认识互联网的角度"></a>两个认识互联网的角度</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>课本是从这个角度来讲解的，我们从这个角度来学习。</p>
<h1 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h1><p>定义：计算机网络由若干<strong>结点</strong>（node）和连接这些结点的<strong>链路</strong>（link）组成。</p>
<h2 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h2><p>可以是计算机、集线器、路由器、交换机等。</p>
<h2 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h2><h1 id="互连网与互联网"><a href="#互连网与互联网" class="headerlink" title="互连网与互联网"></a>互连网与互联网</h1><h2 id="互连网"><a href="#互连网" class="headerlink" title="互连网"></a>互连网</h2><p>internet</p>
<ul>
<li><p>定义</p>
<p>  通用名词，泛指通过路由器将网络连起来形成的网络。</p>
</li>
<li><p>其中网络间的通信协议可以是<strong>任意</strong>的。</p>
</li>
<li><p>互连不仅是物理上，还要通过软件连接。</p>
</li>
</ul>
<h2 id="互联网-1"><a href="#互联网-1" class="headerlink" title="互联网"></a>互联网</h2><p>Internet</p>
<ul>
<li><p>定义</p>
<p>  互联网是全球最大的、开放的、由众多网络相互连接而成的特定互连网。</p>
</li>
<li><p>采用<strong>TCP&#x2F;IP协议族</strong>作为通信规则。</p>
</li>
<li><p>前身是美国的ARPANET。</p>
</li>
</ul>
<h1 id="三层ISP结构"><a href="#三层ISP结构" class="headerlink" title="三层ISP结构"></a>三层ISP结构</h1><p>ISP，互联网服务提供者。</p>
<p>互联网现在采用三层ISP结构。</p>
<h2 id="本地ISP"><a href="#本地ISP" class="headerlink" title="本地ISP"></a>本地ISP</h2><h2 id="地区ISP"><a href="#地区ISP" class="headerlink" title="地区ISP"></a>地区ISP</h2><h2 id="主干ISP"><a href="#主干ISP" class="headerlink" title="主干ISP"></a>主干ISP</h2><h1 id="IXP"><a href="#IXP" class="headerlink" title="IXP"></a>IXP</h1><p>允许两个网络直接相连并交换信息。</p>
<h1 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h1><h2 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h2><p>与网络相连的计算机常称为主机。</p>
<ul>
<li><p>定义</p>
<p>  连接在互联网上的所有主机。</p>
</li>
<li><p>由用户（个人、公司）控制。</p>
</li>
<li><p><strong>进行通信和资源共享</strong>。</p>
</li>
</ul>
<h3 id="主机通信方式"><a href="#主机通信方式" class="headerlink" title="主机通信方式"></a>主机通信方式</h3><ul>
<li><p>对象</p>
<p>  计算机通信的对象是应用层中的<strong>进程</strong>。</p>
</li>
</ul>
<h4 id="客户-x2F-服务器方式"><a href="#客户-x2F-服务器方式" class="headerlink" title="客户&#x2F;服务器方式"></a>客户&#x2F;服务器方式</h4><p>即C&#x2F;S方式。</p>
<ul>
<li><p>客户和服务器指通信中所涉及的两个应用<strong>进程</strong>。</p>
</li>
<li><p>客户&#x2F;服务器模式描述的是进程之间服务和被服务的<strong>关系</strong>。</p>
<p>  客户是服务请求方，服务器是服务提供方。</p>
</li>
<li><p>客户和服务器都要使用互联网核心部分提供的服务。</p>
</li>
<li><p><strong>客户必须知道服务器程序的地址，服务器不需要知道客户程序的地址。</strong></p>
</li>
</ul>
<h4 id="对等连接方式"><a href="#对等连接方式" class="headerlink" title="对等连接方式"></a>对等连接方式</h4><p>对等连接（peer to peer），P2P。</p>
<ul>
<li><p>定义</p>
<p>  两台主机在通信时并不区分谁是客户或服务器。</p>
</li>
<li><p>本质上还是C&#x2F;S方式。</p>
</li>
</ul>
<h2 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h2><ul>
<li><p>定义</p>
<p>  由大量<strong>网络</strong>和连接这些网络的<strong>路由器</strong>组成。</p>
</li>
<li><p>由ISP控制。</p>
</li>
<li><p>为边缘部分提供服务。</p>
</li>
</ul>
<h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>核心部分的工作方式就是路由器的工作方式。</p>
<ul>
<li>存储转发</li>
<li>路由器间不断交换路由信息</li>
</ul>
<h1 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h1><ul>
<li>严格来讲，分组交换也是可以面向连接的</li>
<li>现在用的是分组交换</li>
</ul>
<h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><ul>
<li><p>并不是真正意义上的交换</p>
</li>
<li><p>主要特点：<strong>面向连接</strong></p>
<ul>
<li>建立连接、通信、释放连接</li>
<li><strong>在通信的全部时间内，通信的两个用户始终占用端到端的通信资源。</strong></li>
</ul>
</li>
<li><p>优点</p>
<p>  静态分配传输带宽，只要建立了连接，网络发生拥塞也不会影响通信质量。</p>
</li>
<li><p>缺点</p>
<ul>
<li>计算机通信时，数据具有突发性，线路上真正用来传送数据的时间往往不到10%，造成通信线路资源的浪费。</li>
<li>如果通信链路是由多段链路组成的，只要有一段链路出现故障，就不能通信。</li>
</ul>
</li>
</ul>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><ul>
<li><p>主要特点：采用<strong>存储转发</strong>技术</p>
<ul>
<li>将报文拆分成多个分组，<strong>加上头部</strong></li>
<li>通过路由器以分组为单位进行存储转发</li>
<li>在接收端将分组组装成报文</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>高效</p>
<p>  动态分配传输带宽，<strong>逐段占用通信链路</strong>。</p>
</li>
<li><p>灵活</p>
<p>  为每一个分组独立地选择最合适的转发路由。</p>
</li>
<li><p>迅速</p>
<p>  <strong>不需要建立连接就可以向其他主机发送分组</strong>。</p>
</li>
<li><p>可靠</p>
<ol>
<li><strong>保证可靠性的网络协议、分布式多路由的分组交换网</strong>使网络有很好的生存性。</li>
<li>某个结点或者链路出现故障时，<strong>分组传送的路由可以自适应地动态改变</strong>。</li>
</ol>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>存储转发时需排队，造成一定<strong>时延</strong>。当网络拥塞非常严重时，整个网络也可能会瘫痪。</li>
<li>分组的首部造成一定<strong>开销</strong>。</li>
</ul>
</li>
</ul>
<h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><ul>
<li>主要特点：<ul>
<li>采用存储转发技术，但报文不分组</li>
<li><strong>适用于间歇式轻负载</strong></li>
</ul>
</li>
</ul>
<p>与分组交换相比：</p>
<ul>
<li>优点<ul>
<li>省去了划分分组的步骤</li>
<li>省去了接收端组装分组的步骤</li>
</ul>
</li>
<li>缺点<ul>
<li>灵活性不如分组交换</li>
</ul>
</li>
</ul>
<h2 id="哪个交换方式最好？"><a href="#哪个交换方式最好？" class="headerlink" title="哪个交换方式最好？"></a>哪个交换方式最好？</h2><p>不能说哪个方式一定好或坏</p>
<ul>
<li>若需<strong>连续传送大量数据</strong>，且其<strong>发送时间远大于连接建立时间</strong>，则电路交换的传输速率较快。</li>
<li>报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的<strong>信道利用率</strong>。</li>
<li>由于一个分组的长度远远小于整个报文的长度，因此分组交换比报文交换的时延小；同时也具有更好的灵活性。</li>
</ul>
<h1 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><ul>
<li><p>也称为数据率（data rate）或比特率（bit rate）。</p>
</li>
<li><p>定义</p>
<p>  连接在计算机网络上的<strong>主机</strong>在数字<strong>信道</strong>上<strong>传输数据</strong>的速率。</p>
</li>
<li><p>单位是b&#x2F;s，kb&#x2F;s，Mb&#x2F;s，Gb&#x2F;s</p>
</li>
</ul>
<p>&#x3D;&#x3D;信道：一个发送端，一个接收端&#x3D;&#x3D;</p>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><ul>
<li><p>定义</p>
<p>  数字信道所能传输的<strong>最高</strong>速率。</p>
</li>
<li><p>毫无疑问，带宽单位和速率一样。</p>
</li>
</ul>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><ul>
<li><p>定义</p>
<p>  <strong>单位时间内</strong>通过某个网络（或信道、接口）的<strong>实际的数据量</strong>。</p>
</li>
<li><p>单位是b，Mb等。</p>
</li>
</ul>
<h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>$总时延&#x3D;发送时延+传播时延+处理时延+排队时延$</p>
<ul>
<li><p>一般来说，小时延的网络优于大时延的网络</p>
<p>  一个低速率、小时延的网络可以优于一个高速率、大时延的网络。</p>
</li>
<li><p>在总时延中，哪一种时延占主导地位，必须具体分析。</p>
</li>
</ul>
<h3 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a>发送时延</h3><p>又叫传输时延，发送速率又叫传输速率。</p>
<p>$发送时延&#x3D;\frac{数据帧长度(bit)}{发送速率(bit&#x2F;s)}$</p>
<p>可见发送时延并非固定不变。</p>
<p>对于高速网络链路，我们提高的仅仅是数据的发送速率，而不是比特在链路上的传播速率。</p>
<h3 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h3><p>$传播时延&#x3D;\frac{信道长度(m)}{电磁波在信道上的传播速率(m&#x2F;s)}$</p>
<p><strong>光纤与铜线相比降低了发送时延，光纤的传播速度反而不如铜线传播速度快</strong>。</p>
<h3 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h3><p>主机或路由器在收到分组时要花费一定时间进行处理。</p>
<h3 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h3><p>分组在路由器中可能要排队。</p>
<h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积又称为以比特为单位的链路长度。</p>
<p>$时延带宽积&#x3D;传播时延\times带宽$</p>
<p>时延带宽积反映传输时线路上数据的多少，即<strong>线路上的比特数</strong>。</p>
<p>传播时延决定线路的长度</p>
<p>带宽决定每位的长度</p>
<h2 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h2><p>定义：双向交互一次所需的时间。</p>
<p>从发送方发送数据开始，到发送方收到接收方的确认。</p>
<p><code>ping www.baidu.com</code></p>
<h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><ul>
<li><p><strong>信道利用率并非越高越好</strong></p>
<p>  信道或网络的<strong>利用率</strong>过高会产生非常大的<strong>时延</strong>。</p>
</li>
</ul>
<p>令$D_0$表示网络空闲时的时延，$D$表示网络当前的时延，$U$为网络利用率，</p>
<p>则$D&#x3D;\frac{D_0}{1-U}$。</p>
<h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>$信道利用率&#x3D;\frac{有数据通过时间}{总时间}$</p>
<h3 id="网络利用率"><a href="#网络利用率" class="headerlink" title="网络利用率"></a>网络利用率</h3><p>定义：信道利用率加权平均值</p>
<h1 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h1><h2 id="分层思想"><a href="#分层思想" class="headerlink" title="分层思想"></a>分层思想</h2><ul>
<li><p>相互通信的两个计算机系统必须高度协调，而这种协调是十分复杂的。</p>
<p>  分层可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。</p>
</li>
</ul>
<h2 id="三种分层方法"><a href="#三种分层方法" class="headerlink" title="三种分层方法"></a>三种分层方法</h2><p>OSI是法律上的国际标准，TCP&#x2F;IP是事实上的国际标准。</p>
<p><a href="https://i.loli.net/2019/06/17/5d06f3764b59848351.jpg"><img src="https://i.loli.net/2019/06/17/5d06f3764b59848351.jpg" alt="计算机网络体系结构.jpg"></a></p>
<ul>
<li><p>七层协议：OSI</p>
<p>  <strong>概念清楚</strong>，理论较为完整。</p>
<p>  但既复杂又不实用。</p>
</li>
<li><p>四层协议：TCP&#x2F;IP </p>
<p>  简洁，<strong>得到广泛应用</strong>。</p>
<p>  实质内容只有上三层，网络接口层并没有什么具体内容。</p>
</li>
<li><p>五层协议</p>
<p>  综合七层协议和四层协议的优点：既简洁又能将概念阐述清楚。</p>
</li>
</ul>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>5个</p>
<ul>
<li><p>各层间是独立的</p>
<p>  <strong>每一层只实现一种相对独立的功能</strong>，上层仅知道下层的接口，而不需知道其如何实现。</p>
</li>
<li><p>灵活性好</p>
<p>  只要层间接口关系保持不变，可以对各层进行修改。</p>
</li>
<li><p>结构上可分割开</p>
<p>  各层都可以采用最<strong>合适</strong>的技术实现</p>
</li>
<li><p>易于实现和维护</p>
<p>  整个系统被分解为若干个<strong>相对独立的子系统</strong>，每个子系统都易于实现和维护</p>
</li>
<li><p>能促进标准化工作</p>
<p>  每一层的功能及其所提供的服务都已有了<strong>精确的说明</strong></p>
</li>
</ul>
<h2 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h2><p>分层应使每一层的<strong>功能非常明确</strong>，所以层次的划分并不容易。</p>
<p>层数太少，会使每一层的协议太复杂；</p>
<p>层数太多，会使各层在功能上有重叠，造成额外开销。</p>
<h2 id="对等层"><a href="#对等层" class="headerlink" title="对等层"></a>对等层</h2><p>在OSI参考模型中，位于同一水平行（同一层）上的系统构成了OSI的对等层。</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p><strong>定义</strong>：<strong>在ISO&#x2F;OSI参考模型中，同层对等实体间信息交换时必须遵守的规则。</strong></p>
<p>每层都有协议，有的层只能有一个协议，有的层可以有多个协议。</p>
<p>网络协议主要由以下<strong>三个要素</strong>构成：</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>数据与控制信息的<strong>结构和格式</strong></p>
<h2 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h2><p>需要发出<strong>何种</strong>控制信息，完成<strong>何种</strong>动作以及做出<strong>何种</strong>响应</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p><strong>事件实现顺序</strong>的详细说明</p>
<hr>
<p>作者：<a href="https://github.com/chouxianyu">@臭咸鱼</a></p>
<p>转载请注明出处：<a href="https://chouxianyu.github.io/">https://chouxianyu.github.io</a></p>
<p>欢迎讨论和交流!</p>
<hr>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-网络层复习</title>
    <url>/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="主要解决的问题"><a href="#主要解决的问题" class="headerlink" title="主要解决的问题"></a>主要解决的问题</h1><p>网络层讨论的问题是多个网络互连的问题，即分组如何从一个网络传送到另一个网络。</p>
<h1 id="协议数据单元"><a href="#协议数据单元" class="headerlink" title="协议数据单元"></a>协议数据单元</h1><p>网络层协议数据单元就是IP数据报，又称为<strong>数据报</strong>、<strong>分组</strong>或<strong>包</strong>。</p>
<h1 id="网络层的两种服务"><a href="#网络层的两种服务" class="headerlink" title="网络层的两种服务"></a>网络层的两种服务</h1><p>网络层的两种服务指的是向运输层提供<strong>无连接</strong>或<strong>面向连接</strong>的服务。</p>
<p>选用哪一种服务的实质是：在计算机通信中，可靠交付应当由谁来负责。是网络（网络层）还是端系统（网络层的上几层）？</p>
<p><strong>可靠</strong>：<strong>分组无差错按序到达终点，不丢失，不重复</strong></p>
<p>互联网的设计思路：<strong>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</strong>。<strong>分组不进行编号</strong>。</p>
<h1 id="虚电路和数据报网络对比"><a href="#虚电路和数据报网络对比" class="headerlink" title="虚电路和数据报网络对比"></a>虚电路和数据报网络对比</h1><p>7个方面</p>
<table>
<thead>
<tr>
<th align="center">对比的方面</th>
<th align="center">虚电路服务</th>
<th align="center">数据报服务</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可靠性由谁保证</td>
<td align="center">可靠由网络来保证</td>
<td align="center">可靠由用户主机来保证</td>
</tr>
<tr>
<td align="center">是否面向连接</td>
<td align="center">面向连接</td>
<td align="center">无连接</td>
</tr>
<tr>
<td align="center">是否有终点地址</td>
<td align="center">仅在连接建立阶段使用，每个分组使用短的虚电路号</td>
<td align="center">每个分组都有终点的完整地址</td>
</tr>
<tr>
<td align="center">分组转发方式</td>
<td align="center">属于同一虚电路的分组按同一路由转发</td>
<td align="center">每个分组独立选择路由进行转发</td>
</tr>
<tr>
<td align="center">结点故障对网络的影响</td>
<td align="center">所有通过故障结点的虚电路均不能工作</td>
<td align="center">出故障的结点可能会丢失分组，一些路由可能发生变化</td>
</tr>
<tr>
<td align="center">分组到达终点顺序</td>
<td align="center">按发送顺序到达</td>
<td align="center">不一定按发送顺序到达</td>
</tr>
<tr>
<td align="center">端到端的差错处理和流量控制</td>
<td align="center">可以由网络负责，也可以由用户主机负责</td>
<td align="center">用户主机负责</td>
</tr>
</tbody></table>
<p><strong>互联网的IP协议提供不可靠的无连接的服务</strong>。</p>
<h1 id="中间设备"><a href="#中间设备" class="headerlink" title="中间设备"></a>中间设备</h1><table>
<thead>
<tr>
<th align="center">工作层次</th>
<th align="center">中间设备</th>
</tr>
</thead>
<tbody><tr>
<td align="center">物理层</td>
<td align="center">转发器</td>
</tr>
<tr>
<td align="center">数据链路层</td>
<td align="center">网桥&#x2F;桥接器</td>
</tr>
<tr>
<td align="center">网络层</td>
<td align="center">路由器</td>
</tr>
<tr>
<td align="center">网络层以上</td>
<td align="center">网关</td>
</tr>
</tbody></table>
<h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p>以32位IP地址为例，A、B、C类地址都是单播地址，都由两个固定长度的字段组成，第一个字段是<strong>网络号</strong>，第二个字段是<strong>主机号</strong>。一个网络号在整个互联网范围内是唯一的，一个主机号在其网络内必须是唯一的。</p>
<p>一个IP只能对应一个主机；一个主机可以有多个IP，比如路由器。</p>
<h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2><p>A、B、C类地址的网络号字段分别是1个、2个和3个字节长，其网络号字段前几位是<strong>类别号</strong>。</p>
<table>
<thead>
<tr>
<th align="center">IP地址类型</th>
<th align="center">类别号</th>
<th align="center">可指派网络号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A类</td>
<td align="center">0</td>
<td align="center">1-126</td>
</tr>
<tr>
<td align="center">B类</td>
<td align="center">10</td>
<td align="center">128.1-191.255</td>
</tr>
<tr>
<td align="center">C类</td>
<td align="center">110</td>
<td align="center">192.0.1-233.255.255</td>
</tr>
</tbody></table>
<p>网络号127被保留作为<strong>本地环回测试</strong>，全0被保留表示<strong>本网络</strong>。</p>
<h2 id="既然有了MAC地址，为什么要用IP地址？"><a href="#既然有了MAC地址，为什么要用IP地址？" class="headerlink" title="既然有了MAC地址，为什么要用IP地址？"></a>既然有了MAC地址，为什么要用IP地址？</h2><p>全世界存在<strong>各式各样的网络</strong>，它们使用<strong>不同的硬件地址</strong>。要使这些<strong>异构网络</strong>能够互相通信就必须进行<strong>非常复杂的硬件地址转换工作</strong>，因此由用户主机来完成这项工作几乎是不可能的事。但IP编址把这个复杂问题解决了。</p>
<h1 id="分组转发"><a href="#分组转发" class="headerlink" title="分组转发"></a>分组转发</h1><p>路由表指出<strong>到某个网络应该如何转发</strong>，每行对应于一个网络。</p>
<p>在互联网上转发分组时，是<strong>从一个路由器转发到下一个路由器</strong>。</p>
<p>每条路由主要信息：<strong>（目的网络地址，下一跳地址）</strong>。下一跳地址是路由器端口的IP地址。</p>
<ul>
<li>使用子网时分组的转发</li>
</ul>
<p>使用子网划分后，每条路由主要信息：<strong>（目的网络地址，子网掩码，下一跳地址）</strong>。</p>
<p><strong>主机</strong></p>
<p>要发数据包时先<strong>判断是直接交付还是间接交付</strong>：即发送的这个分组是在本子网上进行直接交付还是要通过本子网的路由器进行间接交付：将与本子网的子网掩码和目的IP地址相与求得目的网络地址与该子网地址比较，得出是否直接交付。</p>
<p><strong>路由器</strong></p>
<ol>
<li>拿到目的IP地址后<strong>对路由器直接相连的网络逐个进行检查</strong>（直接相连的网络可以直接写在路由表的最前边），将各网络的子网掩码和目的IP地址<strong>相与求得目的网络地址</strong>，判断该网络地址是否和对应的目的网络地址匹配。若匹配则直接交付，转发任务结束；否则就是间接交付，进行下一步。</li>
<li>若有<strong>特定主机路由</strong>，则把数据传送给路由表中指明的下一跳，否则执行下一步。</li>
<li>用<strong>路由表每一行</strong>中的子网掩码和目的IP地址相与，若结果与该行目的网络地址匹配，则把数据传送给该行指明的下一跳路由器；否则执行下一步</li>
<li>若路由表中有一个<strong>默认路由</strong>，则把数据报传送给路由表指定的默认路由器；否则，执行下一步</li>
<li><strong>报告转发分组出错</strong>。</li>
</ol>
<h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>功能：从网络层使用的IP地址，解析出在数据链路层使用的硬件地址。</p>
<p>操作：去ARP高速缓存里找，找不到就广播ARP请求分组获得目的硬件地址（可以是路由器或主机的）并记录在ARP高速缓存中。</p>
<h2 id="ARP消息类型"><a href="#ARP消息类型" class="headerlink" title="ARP消息类型"></a>ARP消息类型</h2><ul>
<li>ARP request<ul>
<li>ARP请求分组（1），用于请求某IP主机的硬件地址。</li>
<li><strong>广播</strong>。</li>
<li>主要内容：我的IP是xxx，我的硬件地址是xxx，我想知道IP地址是xxx的地址。</li>
</ul>
</li>
<li>ARP response<ul>
<li>ARP响应分组（2），用于指出某IP主机的硬件地址。</li>
<li><strong>单播</strong>。</li>
<li>主要内容：我的IP是xxx，我的硬件地址是xxx</li>
</ul>
</li>
</ul>
<p>假设主机A发送ARP请求分组请求主机B的物理地址，不久之后很有可能B也要向A发送数据报。所以ARP请求分组包含了源IP，B收到ARP请求分组时会把A的IP地址和物理地址记录在其ARP高速缓存中。</p>
<h2 id="ARP高速缓存"><a href="#ARP高速缓存" class="headerlink" title="ARP高速缓存"></a>ARP高速缓存</h2><p>如果没有ARP高速缓存，任何一台主机每次进行通信时都必须在网络上广播ARP请求分组，使网络上的通信量大大增加。</p>
<h2 id="生存时间"><a href="#生存时间" class="headerlink" title="生存时间"></a>生存时间</h2><ul>
<li>ARP对保存在ARP高速缓存中的每一个映射地址项目都设置生存时间，凡超过生存时间的项目就从高速缓存中删除掉。这样可以及时更新各主机与其物理地址的映射关系，处理主机网络适配器故障或更新等情况。</li>
<li>生存时间设置得太长会使映射关系发生变化的主机迟迟无法通信，设置得太短会使ARP请求和响应分组的通信太频繁。</li>
</ul>
<h2 id="ARP属于网络层"><a href="#ARP属于网络层" class="headerlink" title="ARP属于网络层"></a>ARP属于网络层</h2><p>不能说“ARP向网络层提供了服务”，因为ARP本身是网络层的一部分。数据链路层使用硬件地址而不使用IP地址，因此ARP不在数据链路层。</p>
<h2 id="不需要发送ARP请求分组的情况"><a href="#不需要发送ARP请求分组的情况" class="headerlink" title="不需要发送ARP请求分组的情况"></a>不需要发送ARP请求分组的情况</h2><ul>
<li>源主机的ARP高速缓存中已有目的IP地址的项目</li>
<li>源主机发送广播分组</li>
<li>源主机和目的主机使用点对点链路</li>
</ul>
<h1 id="IP子网"><a href="#IP子网" class="headerlink" title="IP子网"></a>IP子网</h1><p>IP地址与子网掩码相与</p>
<p>同样的IP地址和不同的子网掩码可以得出相同的网络地址。但是不同的掩码效果是不同的：可划分的子网数和每一个子网中的最大主机数都是不一样的。</p>
<p>知道A和B的IP，想让他们在一个子网内，应如何给它们分配子网掩码？</p>
<p>计算子网号个数时要去除全0和全1的情况，即减2。</p>
<hr>
<p>作者：<a href="https://github.com/chouxianyu">@臭咸鱼</a></p>
<p>转载请注明出处：<a href="https://chouxianyu.github.io/">https://chouxianyu.github.io</a></p>
<p>欢迎讨论和交流!</p>
<hr>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-运输层复习</title>
    <url>/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>实现两台主机中<strong>进程之间</strong>的通信。</p>
<ul>
<li><p>复用和分用</p>
<ul>
<li><p>复用</p>
<p>  多个应用层进程可使用同一运输层服务</p>
</li>
<li><p>分用</p>
<p>  运输层把收到的信息分别交付上面应用层的相应进程</p>
</li>
</ul>
</li>
<li><p>提供可靠性</p>
</li>
</ul>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><ul>
<li>面向连接</li>
<li><strong>面向字节流</strong></li>
<li>提供可靠性</li>
<li>不提供广播或多播服务</li>
<li>协议数据单元是<strong>TCP报文段</strong></li>
<li>有拥塞控制</li>
</ul>
<p>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。</p>
<p><strong>套接字</strong>：IP地址+端口号</p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><ul>
<li>无连接</li>
<li>面向报文（给什么数据，传什么数据）</li>
<li>尽最大努力交付</li>
<li>可以一对多、多对一、多对多</li>
<li>协议数据单元是<strong>UDP用户数据报</strong></li>
<li>没有拥塞控制</li>
</ul>
<h1 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h1><ul>
<li><p><strong>无差错情况</strong>：停止等待</p>
<p>  每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组。</p>
</li>
<li><p><strong>出现差错</strong>：超时重传</p>
<p>  每发送完一个分组时设置一个超时计数器。</p>
<p>  如果超时还未收到确认，就重传分组；在超时前收到确认则撤销该超时计数器。</p>
<ul>
<li><p>A发送完一个分组后<strong>必须暂时保留已发送到分组的副本</strong>，在收到响应确认后才能清除这个副本。</p>
</li>
<li><p>分组和确认分组必须进行<strong>编号</strong>，这样才能明确发送出去的分组是哪一个收到了确认，哪一个没有收到确认。</p>
<p>  可以处理确认迟到的情况。</p>
</li>
<li><p>超时计数器设置的<strong>重传时间应当比数据在分组传输的平均往返时间长一些</strong>。如果设定得很长，通信效率就会降低；如果设定得太短，会导致不必要的重传，浪费了网络资源。</p>
</li>
</ul>
</li>
<li><p><strong>确认丢失</strong></p>
<p>  确认丢失时，发送方进行超时重传，而<strong>接收方丢弃这个重复的分组</strong>，<strong>向发送方发送确认</strong>。</p>
</li>
<li><p><strong>确认迟到</strong></p>
<p>  确认迟到了，发送方进行超时重传，而<strong>接收方丢弃这个重复的分组</strong>，<strong>向发送方发送确认</strong>。</p>
<p>  发送方收到迟到的确认什么也不做。</p>
</li>
</ul>
<h1 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h1><p>TCP进行拥塞控制的一种算法。</p>
<p>拥塞是运输层的概念。</p>
<p>发送方维持一个变量：<strong>拥塞窗口</strong>，让自己的<strong>发送窗口等于拥塞窗口</strong>，<strong>拥塞窗口的大小取决于网络的拥塞程度</strong>。</p>
<p><strong>判断网络拥塞的依据就是出现了超时</strong>。网络拥塞时就把拥塞窗口减小一些。</p>
<p>慢开始：<strong>由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值</strong>。</p>
<p>发送方每收到一个对新报文段的确认就使发送方的拥塞窗口+1。</p>
<hr>
<p>作者：<a href="https://github.com/chouxianyu">@臭咸鱼</a></p>
<p>转载请注明出处：<a href="https://chouxianyu.github.io/">https://chouxianyu.github.io</a></p>
<p>欢迎讨论和交流!</p>
<hr>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述</title>
    <url>/2019/06/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>之前看韩利辉计网视频的笔记。</p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>覆盖范围小 自己花钱买设备 带宽固定 自己维护</p>
<p>比如学院的局域网：</p>
<p>机房的汇聚层交换机连接各教室的交换机，教室的接入层交换机连接各电脑。</p>
<p>两两之间的网线不超过100米，10M 100M 1000M</p>
<p>接入层交换机带宽为百兆，每个口都是百兆。汇聚层交换机带宽要比接入层交换机大。</p>
<p>规范的局域网应该是分层的</p>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>超过100米，比如电话线拨号上网，带宽不固定，花钱买带宽、维护等服务</p>
<h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><p>由众多ISP组成，ISP是Internet Service Provider，因特网服务提供商。</p>
<p>各提供商都有自己的机房，对网民提供Internet连接。</p>
<p>各提供商之间最多有一根线相连，所以我用移动的网访问电信的服务器可能会很慢。</p>
<p>有的网站会在各运营商的机房都买一个服务器，或者双线机房（机房里有两种运营商）。</p>
<h1 id="IP和MAC"><a href="#IP和MAC" class="headerlink" title="IP和MAC"></a>IP和MAC</h1><p>计算机有一个IP地址。</p>
<p>网段。</p>
<p>子网掩码，告诉计算机哪儿是网络部分，哪儿是主机部分。</p>
<p>路由器作用：负责在不同网段转发数据</p>
<p>路由器的端口也有MAC地址</p>
<p>路由器的端口相当于计算机的一个网卡，也有地址</p>
<p>网关：告诉计算机去哪个网段，&#x3D;&#x3D;指向路由器&#x3D;&#x3D;。</p>
<p>网卡：MAC地址（物理地址，唯一），出厂已经固定在网卡里，48位二进制。</p>
<p>MAC和IP分别是物理和逻辑上的概念</p>
<p>计算机上发数据包给DNS服务器（计算机配的有），DNS将域名解析成IP，返给计算机</p>
<h1 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h1><p>数据、源IP、目标IP</p>
<p>就像一封信</p>
<p>计算机数据包最大1500字节。</p>
<p>数据一次传不完的话，数据帧是有编号的。</p>
<h1 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h1><p>数据包加上源MAC、目标MAC，就是数据帧。</p>
<p>想把数据包传给目标IP，需要路由器，用MAC找到路由器。</p>
<p>然后路由器根据目标IP更新源MAC和目标MAC，最短路径。</p>
<p>数据帧传给交换机，交换机传给路由器，路由器给路由器，最后给交换机，交换机给计算机。</p>
<p>客户机：给我数据</p>
<p>服务器：好的，给你</p>
<p>客户机：已接收，给我下一个数据</p>
<p>服务器：好的，给你</p>
<p>服务器不知道客户机的MAC地址，可以知道客户机的IP。</p>
<p>为什么不能只用MAC标识电脑？</p>
<p>如果全球计算机都是用交换机连接的，不需要路由器，就可以只用MAC标识电脑。但这不可能。</p>
<p>网卡有缓存，发送缓存，接收缓存。</p>
<h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><p>7层，国际标准化组织分析计算机通讯得出的。</p>
<p>好处：</p>
<p>不同厂商生产设备可以一起用</p>
<p>各层较为独立，每一个模块有变化，不会影响另一个模块。这并不代表各层之间没有关系。</p>
<p>k层为k+1层提供服务。</p>
<p>分层的思想是使用网络的指导原则。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>所有能产生网络流量的程序，记事本就不是，QQ就是。</p>
<h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>在传输之前进行的东西。</p>
<p>比如在切割成数据包传输之前是否进行压缩、加密处理、编码</p>
<h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>session，规定哪个服务器和客户机哪个窗口交互。</p>
<p>cmd中输入<code>netstat -n</code> 可以查看会话。</p>
<p>只要和其他计算机有数据传输，就会建立会话。我们就可以查到它。</p>
<p>通过查看会话 可以查木马。木马和病毒不一样。</p>
<p>输入<code>netstat -nb</code>可以会话是谁建立的。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>实现可靠传输、流量控制、不可靠传输。</p>
<p>可靠传输：超时重传 </p>
<p>流量控制：客户机给服务器一个数据包说慢点</p>
<p>不可靠传输：比如向DNS通过域名查IP，双方一个数据包就可以解决问题，这种通讯不需要建立会话，不需要给数据包编号。就不用超时重传，再来一次就好了。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>选择最佳路径、规划IP地址。</p>
<p>人工指定路径：通过静态路由</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>定义帧的开始和结束、透明传输、差错校验。</p>
<p>用特殊位表示开始和结束，看到开始标志就接收 看到结束标志就结束</p>
<p>启动密码子 终止密码子</p>
<p>透明传输：一部分数据和结束位一样，会在数据那里插入一个特殊的位，表明这不是真正的结束。接收端接收以后再把插入的位去掉。</p>
<p>差错检验：查出错误，但不会纠正错误，纠正是传输层做的</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>定义网络设备接口标准、电气标准、如何在物理链路上传输得更快</p>
<p>接口标准：不同公司生产的网线、网卡都能使用</p>
<p>电气标准：比如用几伏电压代表1。</p>
<h1 id="OSI和网络排错"><a href="#OSI和网络排错" class="headerlink" title="OSI和网络排错"></a>OSI和网络排错</h1><p>应该从最底层开始查找。</p>
<h2 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h2><p>查看连接状态、查看发送和接受到的数据包大小。</p>
<h2 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>MAC地址冲突、ADSL欠费、网速没办法协商、计算机连接到错误的VLAN</p>
<h2 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h2><p>配置了错误的IP地址、子网掩码、网关</p>
<p>路由器上没有到达目标网络的路由</p>
<h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><p>应用层在这儿指网络层之上的</p>
<p>应用程序配置错误</p>
<h1 id="OSI和网络安全"><a href="#OSI和网络安全" class="headerlink" title="OSI和网络安全"></a>OSI和网络安全</h1><h2 id="物理层-2"><a href="#物理层-2" class="headerlink" title="物理层"></a>物理层</h2><p>交换机不用的口 把网线拔掉</p>
<h2 id="数据链路层-2"><a href="#数据链路层-2" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>ADSL账号密码、无线AP、VLAN、交换机端口绑定MAC地址</p>
<h2 id="网络层-2"><a href="#网络层-2" class="headerlink" title="网络层"></a>网络层</h2><p>在路由器上使用ACL控制数据包流量、Windows高级防火墙</p>
<h2 id="应用层-2"><a href="#应用层-2" class="headerlink" title="应用层"></a>应用层</h2><p>应用层在这儿指网络层之上的。</p>
<p>开发的应用程序没漏洞</p>
<p>SQL注入</p>
<h1 id="OSI和TCP-x2F-IP协议"><a href="#OSI和TCP-x2F-IP协议" class="headerlink" title="OSI和TCP&#x2F;IP协议"></a>OSI和TCP&#x2F;IP协议</h1><hr>
<p>作者：<a href="https://github.com/chouxianyu">@臭咸鱼</a></p>
<p>转载请注明出处：<a href="https://chouxianyu.github.io/">https://chouxianyu.github.io</a></p>
<p>欢迎讨论和交流!</p>
<hr>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
